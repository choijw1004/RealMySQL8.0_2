### GROUP BY가 포함된 JOIN UPDATE

부서별 직원 수를 departments 테이블에 저장하고 싶다고 가정하자.

```sql
ALTER TABLE departments ADD emp_count INT;

UPDATE departments d, dept_emp de
	SET d.emp_count = COUNT(*)
WHERE de.dept_no = d.dept_no
GROUP BY de.dept_no;
```

하지만 이 쿼리는 다음과 같은 에러를 발생시킨다.

```
Error Code: 1064. You have an error in your SQL syntax; 
check the manual that corresponds to your MySQL server version for the right syntax to use near 'GROUP BY de.dept_no' at line 4

```

<br/>

### 왜 안 될까?

JOIN UPDATE(다중 테이블 UPDATE)에서 **GROUP BY와 ORDER BY, LIMIT은 사용할 수 없다.** 이것은 MySQL 공식 문서에도 명시되어 있다.

> "For the multiple-table syntax, UPDATE updates rows in each table named in table_references that satisfy the conditions. In this case, **ORDER BY and LIMIT cannot be used.**"

그렇다면 왜 이런 제약이 있을까? 

단일 테이블 UPDATE는 다음과 같이 동작한다.

1. WHERE 조건에 맞는 레코드를 찾는다
2. ORDER BY로 정렬한다
3. LIMIT 개수만큼 업데이트한다

#### 다중 테이블 UPDATE의 동작

다중 테이블 UPDATE는 **조인 결과** 를 기반으로 동작한다.

1. 테이블들을 조인한다
2. 조인 결과의 각 행에 대해 SET 절을 적용한다

여기서 문제가 발생한다. **조인 결과가 항상 일정하지 않다.** 옵티마이저가 어떤 테이블을 먼저 읽느냐(드라이빙 테이블)에 따라 조인 순서와 중간 결과가 달라질 수 있다.

#### GROUP BY가 안 되는 이유

GROUP BY를 사용한 집계(COUNT, SUM 등)는 **여러 행을 하나로 묶는 작업** 이다. 그런데 UPDATE는 **개별 행을 변경하는 작업** 이다. 이 두 가지는 개념적으로 충돌한다.

- COUNT(*)는 그룹 단위로 계산된다
- 하지만 UPDATE는 행 단위로 실행된다
- 집계 결과를 "어떤 행에" 적용해야 하는지 모호해진다

JOIN UPDATE에서 GROUP BY, ORDER BY, LIMIT을 사용할 수 없는 것은 문법적 제약이 아니라, **논리적으로 모호한 상황을 방지** 하기 위한 설계상의 결정이다.

<br/>

**왜 드라이빙 테이블 선택이 중요한가?**

- 드라이빙 테이블은 **풀 스캔** 또는 인덱스 레인지 스캔으로 읽힌다
- 드리븐 테이블은 드라이빙 테이블의 **각 행마다** 조인 조건으로 검색된다
- 드리븐 테이블에 적절한 인덱스가 있으면 빠르게 검색된다

**일반적인 최적화 원칙**
- 결과 행 수가 적은 테이블을 드라이빙으로 선택
- 드리븐 테이블의 조인 칼럼에는 인덱스가 있어야 함
- 파생 테이블(임시 테이블)은 인덱스가 없으므로 드라이빙으로 선택하는 것이 유리할 수 있음

<br/>

문제 쿼리를 다른 방식으로 작성하여 해결할 수 있다.

### 1. 서브쿼리를 활용한 파생 테이블

가장 기본적인 해결책은 **서브쿼리로 미리 집계한 결과** 를 파생 테이블(Derived Table)로 만들어 조인하는 것이다.

```sql
UPDATE departments d,
       (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc -- 부서별 인원수 표를 만들어놓은 뒤 조인
SET d.emp_count = dc.emp_count
WHERE dc.dept_no = d.dept_no;
```

이 쿼리의 실행 과정은 다음과 같다.

1. 서브쿼리가 먼저 실행되어 부서별 직원 수를 계산한다
2. 그 결과가 임시 테이블(파생 테이블 `dc`)로 생성된다
3. departments와 파생 테이블을 조인한다
4. 조인 결과에 따라 UPDATE를 수행한다

**여기서 GROUP BY는 서브쿼리 내부에서 실행되므로 JOIN UPDATE의 제약에 걸리지 않는다.**

<br/>

### 2. STRAIGHT_JOIN으로 조인 순서 강제

옵티마이저가 선택한 조인 순서가 비효율적일 수 있다. 이때 **STRAIGHT_JOIN** 을 사용하면 조인 순서를 강제할 수 있다.

```sql
UPDATE (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc
       STRAIGHT_JOIN departments d ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;
```

<br/>

### 3. JOIN_ORDER 옵티마이저 힌트

MySQL 8.0부터는 STRAIGHT_JOIN의 단점을 보완한 **옵티마이저 힌트** 가 추가되었다.

```sql
UPDATE /*+ JOIN_ORDER(dc, d) */
       (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc
       INNER JOIN departments d ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;
```

**JOIN_ORDER의 장점:**
- 일부 테이블의 순서만 지정하고 나머지는 옵티마이저에게 위임 가능
- 힌트 문법이므로 무시되어도 쿼리 실행에 문제 없음
- 가독성이 더 좋음

<br/>

### 4. LATERAL 조인 (MySQL 8.0.14+)

지금까지의 방법은 모두 서브쿼리를 먼저 실행하고 그 결과를 파생 테이블로 만드는 방식이었다. **LATERAL 조인** 은 완전히 다른 접근 방식이다.

```sql
UPDATE departments d
INNER JOIN LATERAL (
    SELECT de.dept_no, COUNT(*) AS emp_count
    FROM dept_emp de
    WHERE de.dept_no = d.dept_no  -- 외부 테이블 참조
) dc ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;
```

<br/>

### 실행 계획으로 비교하기

실제로 각 방식의 실행 계획을 비교해보자. 테스트 환경은 departments 9건, dept_emp 10,000건이다.

#### 1. 기본 파생 테이블

```sql
EXPLAIN ANALYZE
UPDATE departments d,
       (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc
SET d.emp_count = dc.emp_count
WHERE dc.dept_no = d.dept_no;
```

```sql
-> Update d (immediate)  (actual time=6.02..6.02 rows=0 loops=1)
    -> Nested loop inner join  (cost=9537 rows=93033) (actual time=6..6.01 rows=9 loops=1)
        -> Table scan on d  (cost=1.15 rows=9) (actual time=0.0236..0.0315 rows=9 loops=1)
        -> Index lookup on dc using <auto_key0> (dept_no=d.dept_no)  (cost=3107..3134 rows=103) (actual time=0.664..0.664 rows=1 loops=9)
            -> Materialize  (cost=3107..3107 rows=10337) (actual time=5.97..5.97 rows=9 loops=1)
                -> Group aggregate: count(0)  (cost=2073 rows=10337) (actual time=0.67..5.95 rows=9 loops=1)
                    -> Covering index scan on de using idx_dept_no  (cost=1039 rows=10337) (actual time=0.0075..5.19 rows=10000 loops=1)
```

#### 2. STRAIGHT_JOIN / JOIN_ORDER

```sql
-- STRAIGHT_JOIN (파생 테이블 → departments 순서 강제)
EXPLAIN ANALYZE
UPDATE (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc
       STRAIGHT_JOIN departments d ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;

-- JOIN_ORDER 힌트 사용
EXPLAIN ANALYZE
UPDATE /*+ JOIN_ORDER(dc, d) */
       (SELECT de.dept_no, COUNT(*) AS emp_count
        FROM dept_emp de
        GROUP BY de.dept_no) dc
       INNER JOIN departments d ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;
```

STRAIGHT JOIN 의 실행계획은
```sql
-> Update d (buffered)  (actual time=6.59..6.59 rows=0 loops=1)
    -> Nested loop inner join  (cost=6857 rows=10337) (actual time=6.57..6.59 rows=9 loops=1)
        -> Table scan on dc  (cost=3107..3239 rows=10337) (actual time=6.56..6.56 rows=9 loops=1)
            -> Materialize  (cost=3107..3107 rows=10337) (actual time=6.56..6.56 rows=9 loops=1)
                -> Group aggregate: count(0)  (cost=2073 rows=10337) (actual time=0.764..6.54 rows=9 loops=1)
                    -> Covering index scan on de using idx_dept_no  (cost=1039 rows=10337) (actual time=0.0235..5.71 rows=10000 loops=1)
        -> Single-row index lookup on d using PRIMARY (dept_no=dc.dept_no)  (cost=0.25 rows=1) (actual time=0.00296..0.00297 rows=1 loops=9)
```
다음과같고,

JOIN_ORDER 의 실행계획은
```sql
-> Update d (buffered)  (actual time=6.52..6.52 rows=0 loops=1)
    -> Nested loop inner join  (cost=6857 rows=10337) (actual time=6.5..6.51 rows=9 loops=1)
        -> Table scan on dc  (cost=3107..3239 rows=10337) (actual time=6.48..6.48 rows=9 loops=1)
            -> Materialize  (cost=3107..3107 rows=10337) (actual time=6.48..6.48 rows=9 loops=1)
                -> Group aggregate: count(0)  (cost=2073 rows=10337) (actual time=0.687..6.47 rows=9 loops=1)
                    -> Covering index scan on de using idx_dept_no  (cost=1039 rows=10337) (actual time=0.0236..5.65 rows=10000 loops=1)
        -> Single-row index lookup on d using PRIMARY (dept_no=dc.dept_no)  (cost=0.25 rows=1) (actual time=0.00303..0.00304 rows=1 loops=9)
```
다음과 같다.

둘 다 실행계획이 거의 유사한데 이를 해석하면

#### 3. LATERAL 조인

```sql
EXPLAIN ANALYZE
UPDATE departments d
INNER JOIN LATERAL (
    SELECT de.dept_no, COUNT(*) AS emp_count
    FROM dept_emp de
    WHERE de.dept_no = d.dept_no
) dc ON dc.dept_no = d.dept_no
SET d.emp_count = dc.emp_count;
```

실행계획은 다음과 같고
```sql
-> Update d (immediate)  (actual time=6.29..6.29 rows=0 loops=1)
    -> Nested loop inner join  (cost=7.1 rows=9) (actual time=0.744..6.29 rows=9 loops=1)
        -> Invalidate materialized tables (row from d)  (cost=1.15 rows=9) (actual time=0.0251..0.0337 rows=9 loops=1)
            -> Table scan on d  (cost=1.15 rows=9) (actual time=0.0249..0.033 rows=9 loops=1)
        -> Index lookup on dc using <auto_key0> (dept_no=d.dept_no)  (cost=0.842..1.13 rows=2) (actual time=0.694..0.694 rows=1 loops=9)
            -> Materialize (invalidate on row from d)  (cost=0.55..0.55 rows=1) (actual time=0.693..0.693 rows=1 loops=9)
                -> Aggregate: count(0)  (cost=0.45 rows=1) (actual time=0.691..0.691 rows=1 loops=9)
                    -> Covering index lookup on de using idx_dept_no (dept_no=d.dept_no)  (cost=0.35 rows=1) (actual time=0.00472..0.658 rows=1111 loops=9)

```

<br/>

---

### References

- Real MySQL 8.0
- [MySQL 8.0 Reference Manual - UPDATE Statement](https://dev.mysql.com/doc/refman/8.0/en/update.html)
- [MySQL 8.0 Reference Manual - Optimizer Hints](https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html)
- [MySQL 8.0 Reference Manual - Lateral Derived Tables](https://dev.mysql.com/doc/refman/8.0/en/lateral-derived-tables.html)