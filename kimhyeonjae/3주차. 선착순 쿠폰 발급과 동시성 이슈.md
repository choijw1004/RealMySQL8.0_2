## Race Condition

선착순 100명에게 쿠폰을 발급하는 요구사항을 생각해보자.

```java
public void issueCoupon(Long userId) {
    long count = couponRepository.count();  // 현재 발급된 쿠폰개수 조회
    if (count < 100) {
        couponRepository.save(new Coupon(userId));  // 쿠폰 발급
    }
}
```

이 방법은 단일 스레드 환경에서는 잘 동작한다.

하지만 동시에 여러 요청이 들어오면

```
시간   스레드1              스레드2
───────────────────────────────────────────────────────────
T1    count = 99         
T2                        count = 99
T3    99 < 100 → true    
T4                        99 < 100 → true  
T5    save(쿠폰)          
T6                        save(쿠폰)  ← 101번째 쿠폰 발급!
```

99번째 쿠폰이 발급된 상태에서 여러 스레드가 동시에 `count()`를 호출하면 아직 쿠폰발급 100개 안 됐네 라고 판단하고 쿠폰을 발급해버린다. 

이렇게 **Race Condition** 문제가 발생한다.

<br/>

## MySQL 락으로 해결하기

### `FOR UPDATE` : 비관적 잠금

가장 직관적인 방법은 MySQL의 `FOR UPDATE`를 사용하는 것이다.

```sql
-- 트랜잭션 시작
START TRANSACTION;

-- 쿠폰 이벤트 레코드에 배타적 잠금(X Lock) 획득
SELECT * FROM coupon_event WHERE id = 1 FOR UPDATE;

-- 발급 수량 확인 후 (유효성 검사) 쿠폰 발급

-- ...

COMMIT;
```

`FOR UPDATE`는 해당 레코드에 **배타적 잠금(X Lock)** 을 건다. 다른 트랜잭션이 같은 레코드에 `FOR UPDATE`나 `FOR SHARE`를 시도하면 잠금이 해제될 때까지 대기해야 한다.

```
스레드1                                스레드2
───────────────────────────────────────────────────────────────────
SELECT ... FOR UPDATE (X Lock 획득)
                                      SELECT ... FOR UPDATE
                                      (대기... 잠금 풀릴 때까지)
count 확인 → 발급 → COMMIT
(X Lock 해제)
                                      (잠금 획득)
                                      count 확인 → 발급 → COMMIT
```

동시성 문제는 해결된다. 하지만 100명이 동시에 요청하면 99명이 대기한다.


대기 시간이 길어지면 `Lock wait timeout exceeded` 에러가 발생하고, 유저는 그때까지 계속 기다려야한다.

<br/>

### Lock Compatibility

`SKIP LOCKED`를 설명하기 전에, MySQL의 잠금 호환성을 이해해야 한다.

|                    | X Lock (FOR UPDATE) | S Lock (FOR SHARE) |
| ------------------ | :-----------------: | :----------------: |
| **X Lock 보유 중** |       대기        |       대기       |
| **S Lock 보유 중** |       대기        |       허용       |

**X Lock(배타적 잠금)** 은 다른 어떤 잠금도 허용하지 않는다. 반면 **S Lock(공유 잠금)** 은 다른 S Lock과는 호환된다.

여기서 중요한 점이 하나 있다. **일반 SELECT는 잠금을 요청하지 않는다.**

```sql
-- 세션1
SELECT * FROM coupon WHERE id = 1 FOR UPDATE;  -- X Lock 획득

-- 세션2
SELECT * FROM coupon WHERE id = 1;  -- 즉시 반환 (대기 없음)
```

세션1이 X Lock을 걸어도 세션2의 일반 SELECT는 대기하지 않는다. InnoDB는 **MVCC(Multi-Version Concurrency Control)** 를 사용해서 잠금 없이 과거 스냅샷을 읽기때문이다.

```sql
-- 세션1
SELECT * FROM coupon WHERE id = 1 FOR UPDATE;  -- X Lock 획득

-- 세션2
SELECT * FROM coupon WHERE id = 1 FOR SHARE;  -- 락 대기 (X Lock 해제까지)
```

반면 `FOR SHARE`는 S Lock을 요청하므로, X Lock이 해제될 때까지 대기한다.

<br/>

### `SKIP LOCKED` : 잠긴 레코드 건너뛰기

MySQL 8.0.1부터 도입된 `SKIP LOCKED`는 잠긴 레코드를 건너뛰고 잠금이 걸리지 않은 레코드를 선택한다. 이걸 활용하면 **DB만으로 큐(Queue)** 를 구현할 수 있다.

#### 테이블 설계

```sql
CREATE TABLE coupon (
    coupon_id   BIGINT NOT NULL,
    user_id     BIGINT NULL DEFAULT 0,        -- 0이면 미발급, 발급되면 소유한 사용자 id 저장
    coupon_code VARCHAR(15) NOT NULL,
    issued_at   DATETIME NULL,
    created_at  DATETIME NOT NULL,
    ...
    PRIMARY KEY (coupon_id),
    INDEX idx_userid (user_id)
);

-- 1000개 쿠폰 미리 생성
INSERT INTO coupon (user_id, coupon_code, created_at) 
VALUES ('COUPON-0001', 0, NOW()), ('COUPON-0002', 0, NOW()), ...;
```

#### 발급 쿼리

```sql
START TRANSACTION;

-- 잠기지 않은 미발급 쿠폰 1개를 가져와서 잠금
SELECT * FROM coupon 
WHERE user_id = 0 
LIMIT 1 
FOR UPDATE SKIP LOCKED;

-- 해당 쿠폰에 사용자 할당
UPDATE coupon SET user_id = ?, issued_at = NOW() WHERE id = ?;

COMMIT;
```

#### 동작

`SKIP LOCKED`의 핵심은 **각 트랜잭션이 서로 다른 레코드를 처리** 한다는 점이다.

```
시간   스레드1                  스레드2                  스레드3
─────────────────────────────────────────────────────────────────────────────────
T1    SELECT SKIP LOCKED
      → 쿠폰#1 획득 (X Lock)
      
T2                            SELECT SKIP LOCKED
                              → 쿠폰#1 잠김, SKIP!
                              → 쿠폰#2 획득 (X Lock)
                           
T3                                                     SELECT SKIP LOCKED
                                                       → 쿠폰#1, #2 잠김, SKIP!
                                                       → 쿠폰#3 획득

T4    UPDATE 쿠폰#1           UPDATE 쿠폰#2             UPDATE 쿠폰#3
T5    COMMIT                 COMMIT                    COMMIT
```

기존 `FOR UPDATE`와 비교하면 처리량 차이가 꽤 있다.

```
[FOR UPDATE] - 직렬 처리
요청1: ──────────────────────>
요청2:        (대기)──────────────────────>
요청3:              (대기)(대기)──────────────────────>

[FOR UPDATE SKIP LOCKED] - 병렬 처리
요청1: ──────────────────────>  (쿠폰#1)
요청2: ─"skip"─>──────────────────────>  (쿠폰#2)
요청3: ─"skip"─>─"skip"─>──────────────────────>  (쿠폰#3)
```

#### SKIP LOCKED의 한계

`SKIP LOCKED`는 강력하지만 몇 가지 제약이 있다.

1. **쿠폰을 미리 생성해야 함**
2. **중복 발급 방지가 별도로 필요** : 같은 사용자가 여러 번 요청하는 상황

일단 중복 발급 방지는 `UNIQUE` 제약조건으로 해결할 수 있다.

```sql
ALTER TABLE coupon ADD UNIQUE INDEX uk_user_event (user_id, event_id);
```

<br/>

### NOWAIT: 즉시 실패

`SKIP LOCKED`와 함께 도입된 `NOWAIT`은 잠긴 레코드를 만나면 대기하지 않고 **즉시 에러를 반환** 한다.

```sql
SELECT * FROM coupon WHERE id = 1 FOR UPDATE NOWAIT;

-- 잠긴 상태라면 아래와 같은 에러 반환하면서 종료됨:
-- ERROR 3572: Statement aborted because lock(s) could not be acquired immediately
```

| 옵션            | 동작                      | 적합한 상황                       |
| --------------- | ------------------------- | --------------------------------- |
| **NOWAIT**      | 잠금 충돌 시 즉시 에러    | 특정 좌석 예매 (이미 선택된 좌석) |
| **SKIP LOCKED** | 잠금 충돌 시 다음 행 선택 | 선착순 쿠폰 발급 (아무 쿠폰이나)  |

<br/>

## Redis + Kafka (대규모 트래픽)

`SKIP LOCKED`는 중간규모까지는 충분하지만, 대규모 이벤트에서는 디스크 I/O 자체가 병목이 된다. 이때 `Redis` 와 `Kafka` 를 활용할 수 있다.

### Redis

1. **싱글 스레드** : 모든 명령이 순차 처리되어 원자성 보장됨
2. **인메모리** : 디스크 I/O 없이 초당 10만 건 이상 처리가능함
3. **원자적 연산** : `INCR`, `DECR`, `SETNX` 등

### 아키텍처

```
사용자 요청 (동기)                  백그라운드 (비동기)
────────────────────────────────────────────────────
    │                             
    ▼         

  Redis

    │                             
    ▼                             

  Kafka     →    Consumer    →    MySQL (나중에 저장)
```

사용자에게는 Redis 처리 결과만 즉시 응답하고 실제 DB 저장은 Kafka를 통해 비동기로 처리한다.

> Redis에서 "발급 성공" 응답을 보낸 시점과 실제 DB에 저장되는 시점 사이에 지연이 발생할 수 있다. 여기어때 기술블로그에 따르면, 이 부분은 "이벤트 진행 중, 지급 성공 응답과 실제 쿠폰 지급 처리 사이에 Delay가 발생할 수 있기 때문에, 이벤트 기획 협의를 통해서 적절한 문구로 고객에게 안내 하였습니다." 라고 기술한다.

<br/>

올리브영 기술블로그에서는 Redis Pub/Sub의 "100% 전송 보장이 되지 않는" 특성 때문에 미발급 문제가 발생했고, 이를 Redis List + RabbitMQ로 해결한 과정을 상세히 다룬다.

<br/>

---

### References

- Real MySQL 8.0 2권 - 백은빈, 이성욱